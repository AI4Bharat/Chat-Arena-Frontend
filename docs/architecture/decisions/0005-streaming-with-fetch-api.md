# ADR 0005: Use Fetch API for Streaming Responses

## Status

Accepted

## Context

A core feature of Chat Arena is real-time AI response streaming. We needed to choose a technology for consuming streamed responses from the backend.

Requirements:
- Display text as it's generated by AI models
- Handle multiple simultaneous streams (compare mode)
- Robust error handling and recovery
- Good browser support

### Options Considered

1. **WebSocket (Socket.io)**
   - Bidirectional communication
   - Persistent connection
   - More complex server setup
   - Overkill for unidirectional streaming

2. **Server-Sent Events (EventSource)**
   - Built-in reconnection
   - Simple API
   - GET requests only (no POST body)
   - Limited header support

3. **Fetch API with ReadableStream**
   - Full HTTP semantics (POST, headers)
   - Native browser API
   - Manual stream handling
   - Good browser support

4. **Axios Streaming**
   - Consistent with our HTTP client
   - Limited streaming support
   - Not designed for chunked responses

## Decision

We chose **Fetch API with ReadableStream** for streaming AI responses.

## Rationale

1. **Full HTTP Support**: Can use POST requests with JSON bodies, custom headers, and authentication.

2. **Native API**: No additional dependencies; uses browser's native `fetch()`.

3. **Fine-Grained Control**: Manual stream handling allows custom buffering and parsing.

4. **Flexibility**: Works with any streaming format (SSE-like, JSON lines, raw text).

5. **Parallel Streams**: Easy to manage multiple simultaneous streams in compare mode.

## Implementation

### Stream Handler Hook

```javascript
// useStreamingMessage.js
const useStreamingMessage = (sessionId) => {
  const dispatch = useDispatch();
  const [isStreaming, setIsStreaming] = useState(false);

  const sendMessage = async (content) => {
    setIsStreaming(true);

    try {
      const response = await fetch(`${API_URL}/messages/stream/`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${accessToken}`,
        },
        body: JSON.stringify({ session_id: sessionId, content }),
      });

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value, { stream: true });
        buffer += chunk;

        // Process complete lines
        const lines = buffer.split('\n');
        buffer = lines.pop(); // Keep incomplete line

        for (const line of lines) {
          if (line.trim()) {
            dispatch(updateStreamingMessage({ chunk: line }));
          }
        }
      }

      dispatch(finalizeMessage());
    } catch (error) {
      dispatch(setStreamError(error.message));
    } finally {
      setIsStreaming(false);
    }
  };

  return { sendMessage, isStreaming };
};
```

### Stream Format

```
// Backend sends SSE-like format
data: {"content": "Hello", "status": "streaming"}
data: {"content": " world", "status": "streaming"}
data: {"content": "!", "status": "complete"}

// Compare mode (prefixed by participant)
a0: {"content": "Response from Model A..."}
ad: {"content": "Response from Model B..."}
```

### Buffering Strategy

```javascript
// Buffer updates to reduce render frequency
const FLUSH_INTERVAL = 75; // ms
let pendingUpdate = '';

const flushBuffer = () => {
  if (pendingUpdate) {
    dispatch(updateStreamingMessage({ content: pendingUpdate }));
    pendingUpdate = '';
  }
};

const processChunk = (chunk) => {
  pendingUpdate += chunk;
};

// Flush every 75ms
setInterval(flushBuffer, FLUSH_INTERVAL);
```

## Consequences

### Positive

- Full control over streaming behavior
- Works with authentication headers
- Supports POST requests with body
- Efficient with buffering
- No external dependencies

### Negative

- More code than EventSource
- Manual reconnection logic needed
- Must handle stream parsing

### WebSocket Fallback

Socket.io is available as a fallback but currently unused:

```javascript
// useWebSocket.js exists but streaming uses fetch
// WebSocket can be enabled for features requiring bidirectional communication
```

## Error Handling

```javascript
try {
  // Stream reading
} catch (error) {
  if (error.name === 'AbortError') {
    // User cancelled
  } else if (error.name === 'TypeError') {
    // Network error
  } else {
    // Stream error
  }
  dispatch(setMessageError({ error: error.message }));
}
```

## Related

- [useStreamingMessage Hook](../../../src/features/chat/hooks/useStreamingMessage.js)
- [useStreamingMessageCompare Hook](../../../src/features/chat/hooks/useStreamingMessageCompare.js)